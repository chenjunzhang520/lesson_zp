# JS 执行机制

- JS 执行
  Chrome 浏览器的**V8 引擎**负责代码的编译和执行
- 1.js 一段代码
  代码的编写顺序和执行顺序不一样，v8 引擎会在编译阶段干点啥？
- 两个阶段
  - 编译阶段 
    检测语法错误、变量提升
    js 脚本语言
    编译在执行前的一刹那
  - 执行阶段
    提升的变量早就为我们准备好了 

- v8引擎设计的js 执行机制
  - 编译阶段和执行阶段
  - var 和 let/const 区别

- 编译阶段
  - 一段可执行的代码， 会被执行上下文对象包裹。
  - 创建一个执行上下文对象  context ，为执行做准备
  - 调用栈
    负责将执行上下文对象调入执行栈中执行。
    函数的执行
    - 首先 全局执行上下文会被压入调用栈
    - 有函数要执行的话，创建一个全新的函数执行上下文
      压入调用栈
    ......
    JS代码执行就可以用栈的特征来执行
    - 在栈顶执行一个函数 (单纯)
      执行完后，出栈， 变量垃圾回收

3.js 编译阶段的工作流程
- 一段代码，由v8 引擎接管
  - JS调用栈来管理JS的执行
    以函数为单位
  - 编译阶段
    - 创建全局执行上下文对象
      - 变量环境
        a = undefined
        fn()
      - 词法环境
        空
      - 可执行的代码
- fn(3) 执行阶段
  - 创建新的函数执行上下文对象入栈 (编译阶段)
    - 变量环境
      函数是一等对象
      函数声明更优先
      a是参数
      a = function (参数)
      b = undefined

      var 允许重复声明
    - 词法环境
    - 可执行的代码

- fn 执行阶段
  a  function  -> 2
  b = a = 2 (值拷贝)
  a     2

## 总结
- 代码先编译再执行， 一边编译， 后执行，再编译，再执行
  js 和 C++/java 不一样的原因
- 调用栈  (V8 引擎良好执行代码的数据结构设计)
  1. 编译总是发生在执行前的一刹那
  2. 全局和函数体的编译会生成执行上下文，存入调用栈
  3. 当一个函数执行完后，他的执行上下文会被销毁
- 编译的过程
  1. 创建执行上下文对象
  2. 找形参和变量声明， 提升到变量环境 undefined 
     let/const 声明的变量或常量， 放入词法环境(暂时性死区)
  3. 统一形参和实参的值(全局除外)
  4. 找函数声明， 将函数名作为key， 值为函数体
