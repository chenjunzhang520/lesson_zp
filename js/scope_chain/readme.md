# JS 语言工作的底层机制
- v8 引擎
- 调用栈
  - 编译阶段
  - 执行阶段
- 执行上下文(底层全局,函数)
- 作用域
  变量的查找范围和生命周期
  - 块级作用域  栈结构的词法环境
  - hoisting提升  简单高效

  ## 作用域链
  - 不知道作用域链查找的规则？
    - 我一定要知道查找规则
     - 作用域链 变量的查找路径 
        - 按照我们的申明的时候（编译时候）  已经决定了 词法作用域 
  - 为什么是全局的作用域
    - 为什么不是foo()？  极客帮
    我们的函数在**调用栈**中的顺序   不是这样的

    ## 词法作用域 以及词法作用域链的概念
    - 词法作用域  是由在代码中函数申明中的位置来决定的。词法作用域是静态的作用域
    - 词法作用域链  静态的 ， 只和函数申明的位置相关，在编译阶段就决定好了，和调用没有关系。

## 闭包  closure
无处不在的高级概念
静态的 ， 词法作用域后
- 函数运行的时候， 也有一种情况
就好像函数运行的时候不是在他申明的位置时，作用域链

- 闭包基于词法作用域链
- 形成条件是函数嵌套函数
- 被闭包的函数在外部可以访问到  return 
- 被闭包的函数执行的时候能找到定义它的时候执行上下文中的变量

foo  函数执行完后，其执行上下文从栈顶弹出了，但是由于返回的setName
，
getName 使用了foo函数内部的变量myName 和test1，这两个变量依然会在内存中存在，直到setName,getName函数被垃圾回收机制回收。方法的一个专属背包
这个背包闭包，这个闭包里面的变量叫自由变量，