# JS内存机制

- JS执行机制
  - 调用栈
  - 执行上下文
    - 变量环境
    - 词法环境
    - outer 词法作用域链
      - 闭包 closure 
    - this

- JS 内存
  - 栈内存 简单数据类型
  - 堆内存 复杂数据类型

- JS是什么语言？ 动态弱类型语言
  - 静态语言
  使用之前需要确认变量数据类型的
  - 动态语言
  运行过程中需要检查数据类型的语言
  - 强类型
    不可以设置其他类型
  - 弱类型
    各种类型都可以转换
- js 要直接操作内存不？
  不需要
  c,c++ malloc free 操作内存
  js 不用直接操作内存

- Object 类型
  key:value   key string|symbol  value 类型？
- 八种数据类型
- 简单数据类型和复杂数据类型
  两种机制就搞定了
- 为什么是这两个？

## 内存空间
- 代码空间
  代码从硬盘
  读取到内存中
- 栈内存
  调用栈 (JS执行的主角)
  快，好管理，大小固定
  调用栈的栈顶指针切换要快， 小，连续 切换和频繁
- 堆内存
  打辅助
  大对象的空间，分配更耗时
  对象动态的，不连续的 

  JavaScript V8引擎需要用栈来维护程序执行期间上下文的状态。
  如果栈空间太大了，不连续的(复杂数据类型也放在栈中)，那么会影响上下文切换的效率，进而影响整个程序的执行效率
  执行上下文的切换，其实是执行栈栈顶指针偏移。
  栈空间，用来存放原始数据类型，空间暂居不大，且连续
  堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

  - 简单数据类型直接使用，
  - 复杂数据类型，二传手
    回收的时候 栈回收(指针偏移) 堆内存中的对象没有变量引用，慢慢回收。

## 内存机制理解闭包
- 执行流程
  - 先编译 foo 函数， 创建一个空的执行上下文 (全局执行上下文)
  - 执行foo 之前， 编译过程，setName,getName 快速的词法扫描 (var)
    闭包内部函数，myName test1 由内部函数引用的自由变量，JS 判断有闭包，堆空间中创建一个closure(foo)

  - getName, setName 执行可以访问到closure(foo)

  闭包核心 第一步 需要扫描内部函数 堆内存中 
  第二步 把内部函数引用的外部变量保存到堆中。